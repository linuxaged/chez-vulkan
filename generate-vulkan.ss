(load "~/.ski/do.ss")
(import (scheme)
        (sxml sxpath)
        (srfi :14 char-sets)
        (only (srfi :13 strings)
              string-tokenize
              string-join
              string-index-right
              string-replace
              string-prefix?
              string-suffix?))

(let* ((in (open-file-input-port "vulkan.fasl"))
       (out (open-output-file "vulkan.ss" '(truncate)))
       (sxml ((sxpath '(GCC_XML)) (fasl-read in)))
       (res '())
       (exported-symbols '())
       (output-list '())
       (display (lambda (sexp . internal?)
                  (set! output-list (cons sexp output-list))
                  (if (and (null? internal?)
                           (string-prefix? "define" (symbol->string (car sexp))))
                      (set! exported-symbols (cons (cadr sexp) exported-symbols)))))
       (newline (lambda () (void)))
       )
  (dynamic-wind
    (lambda () (void))
    (lambda ()
      
      (newline)
      (display '(define-ftype integer-128 (struct (lo unsigned-64) (hi integer-64))) #t)
      (newline)
      (display '(define-ftype unsigned-128 (struct (lo unsigned-64) (hi unsigned-64))) #t)
      (newline)
      (display '(define-ftype enum int) #t)
      (newline)
      
      (let* ((vk-enum-symbol (lambda (sym)
                               (let ((str (if (symbol? sym) (symbol->string sym) sym)))
                                 (string->symbol
                                  (let ((dstr (string-downcase
                                               (string-join (string-tokenize str char-set:letter+digit) "-"))))
                                    (if (string-prefix? "vk-" dstr)
                                        (string-append "vk:" (substring dstr 3 (string-length dstr)))
                                        dstr))))))
             (vk-symbol (lambda (sym)
                          (let ((str (if (symbol? sym) (symbol->string sym) sym)))
                            (let ((dstr (string-downcase
                                         (let loop ((str str)
                                                    (i (string-index-right str char-set:upper-case)))
                                           (if (not i)
                                               str
                                               (loop (if (or (= 0 i)
                                                             (char-upper-case? (string-ref str (- i 1))))
                                                         str
                                                         (string-replace str "-" i i))
                                                     (string-index-right str char-set:upper-case 1 i)))))))
                              (vk-enum-symbol dstr)))))
             
             (resolve-type (lambda (type-name)
                             (let ((str (if (symbol? type-name) (symbol->string type-name) type-name)))
                               (cond
                                ((string=? str "signed char") 'integer-8)
                                ((string=? str "unsigned char") 'unsigned-8)
                                ((string=? str "short int") 'integer-16)
                                ((string=? str "short unsigned int") 'unsigned-16)
                                ((string=? str "int") 'integer-32)
                                ((string=? str "unsigned int") 'unsigned-32)
                                ((string=? str "long int") 'integer-64)
                                ((string=? str "long unsigned int") 'unsigned-64)
                                ((string=? str "__int128") 'integer-128)
                                ((string=? str "unsigned __int128") 'unsigned-128)
                                (else (vk-symbol str)))))))
        (for-each (lambda (typedef)
                    (let* ((name (cadar ((sxpath '(@ name)) typedef)))
                           (type (cadar ((sxpath '(@ type)) typedef)))
                           (ref ((sxpath `(* (@ (id (equal? ,type))))) sxml))
                           (refnamel ((sxpath '(name)) ref)))
                      (if (null? refnamel)
                          (if (eq? 'PointerType (caar ((node-parent sxml) ref)))
                              (display `(define-ftype ,(vk-symbol name) uptr))
                              (void) ;(display '(hit!))
                              )
                          (let ((refname (cadar refnamel)))
                            (if (string=? "" refname)
                              (void) ;(display `(define-ftype ,(vk-symbol name) uptr))
                              (if (string=? name refname)
                                  (let ((parent ((node-parent sxml) ref)))
                                    (cond
                                     ((eq? 'Enumeration (caar parent))
                                      (newline)
                                      (display `(define-ftype ,(vk-symbol name) enum))
                                      (for-each (lambda (enum-value)
                                                  (display `(define ,(vk-enum-symbol (cadar ((sxpath '(@ name)) enum-value)))
                                                              ,(string->number (cadar ((sxpath '(@ init)) enum-value))))))
                                                ((sxpath '(EnumValue)) parent)))
                                     ((or (eq? 'Struct (caar parent))
                                          (eq? 'Union (caar parent)))
                                      (let* ((members (string-tokenize (cadar ((sxpath '(members)) ref)) char-set:graphic))
                                             (fields (let loop ((m members)
                                                                (f '()))
                                                       (if (null? m)
                                                           (reverse f)
                                                           (let* ((field ((sxpath `(Field (@ (id (equal? ,(car m)))))) sxml))
                                                                  (type-id (cadar ((sxpath '(type)) field)))
                                                                  (type ((sxpath `(* (@ (id (equal? ,(if (string-suffix? "c" type-id)
                                                                                                         (substring type-id 0 (- (string-length type-id) 1))
                                                                                                         type-id)))))) sxml))
                                                                  (type-namel ((sxpath '(name)) type)))
                                                             (let ((type-name (if (null? type-namel)
                                                                                  (let ((parent ((node-parent sxml) type)))
                                                                                    (cond
                                                                                     ((eq? 'PointerType (caar parent))
                                                                                      'uptr)
                                                                                     ((eq? 'ArrayType (caar parent))
                                                                                      `(array ,(+ (string->number (cadar ((sxpath '(@ max)) parent))) 1)
                                                                                              ,(resolve-type
                                                                                                (cadar ((sxpath '(name))
                                                                                                        ((sxpath `(* (@ (id (equal? ,(cadar ((sxpath '(@ type)) parent)))))))
                                                                                                         sxml))))))
                                                                                     (else
                                                                                      (void))))
                                                                                  (vk-symbol (cadar type-namel)))))
                                                               (loop (cdr m)
                                                                     (cons `(,(vk-symbol (cadar ((sxpath '(name)) field)))
                                                                             ,type-name) f))))))))
                                        (display `(define-ftype ,(vk-symbol name) (,(string->symbol (string-downcase (symbol->string (caar parent)))) ,@fields)))))))
                                  (display `(define-ftype ,(vk-symbol name) ,(resolve-type refname))))
                              )))
                      ))
                  ((sxpath '(Typedef)) sxml))
        (for-each (lambda (function)
                    
                    (let ((func-name (cadar ((sxpath '(@ name)) function)))
                          (return-type-name (resolve-type (cadar ((sxpath '(name)) ((sxpath `(* (@ (id (equal? ,(cadar ((sxpath '(@ returns)) function))))))) sxml)))))
                          (arg-type-list (map (lambda (type-idl)
                                                (let loop ((type ((sxpath `(* (@ (id (equal? ,(cadr type-idl)))))) sxml)))
                                                  (let ((type-namel ((sxpath '(name)) type)))
                                                    (if (null? type-namel)
                                                        (let ((parent ((node-parent sxml) type)))
                                                          (cond
                                                           ((eq? 'PointerType (caar parent))
                                                            'uptr)
                                                           (else
                                                            (let ((type-id-of-type ((sxpath '(type)) type)))
                                                              (loop ((sxpath `(* (@ (id (equal? ,(cadar type-id-of-type)))))) sxml))))))
                                                        (resolve-type (cadar type-namel))))))
                                              ((sxpath '(Argument @ type)) function))))
                      (unless (or (string-suffix? "EXT" func-name)
                                  (string-suffix? "AMD" func-name))
                        (display `(define ,(vk-symbol func-name)
                                    (foreign-procedure ,func-name
                                                       ,arg-type-list
                                                       ,return-type-name))))))
                  ((sxpath '(Function)) sxml)))

      (pretty-print '(load-shared-object "libvulkan.so") out)
      (pretty-print `(library (vulkan)
                       (export ,@(reverse exported-symbols))
                       (import (scheme))
                       ,@(reverse output-list))
                    out)
      )
    (lambda ()
      (close-output-port out)
      (close-port in))))
